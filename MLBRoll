local FRAME_WIDTH, FRAME_HEIGHT = 420, 390
local PADDING = 18

local ROUNDED_EDGE = "Interface\\Tooltips\\UI-Tooltip-Border"
local ROUNDED_EDGE_SIZE = 14
local MAIN_INSETS = { left = 4, right = 4, top = 4, bottom = 4 }
local SUB_INSETS = { left = 3, right = 3, top = 3, bottom = 3 }

local frame = CreateFrame("Frame", "MLBRollFrame", UIParent, "BackdropTemplate")
frame:SetSize(FRAME_WIDTH, FRAME_HEIGHT)
frame:SetPoint("CENTER")
frame:SetMovable(true)
frame:EnableMouse(true)
frame:RegisterForDrag("LeftButton")
frame:SetScript("OnDragStart", frame.StartMoving)
frame:SetScript("OnDragStop", frame.StopMovingOrSizing)
frame:SetBackdrop({
    bgFile = "Interface\\FrameGeneral\\UI-Background-Rock",
    edgeFile = ROUNDED_EDGE,
    tile = true, tileSize = 32, edgeSize = ROUNDED_EDGE_SIZE,
    insets = MAIN_INSETS
})
frame:SetBackdropColor(0.10, 0.13, 0.19, 0.98)
frame:SetToplevel(true)
frame:SetUserPlaced(true)
tinsert(UISpecialFrames, frame:GetName())

local title = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlightLarge")
title:SetPoint("TOP", frame, "TOP", 0, -18)
title:SetText("MLB Roll")
title:SetFont(title:GetFont(), 22)
title:SetTextColor(0.95, 0.95, 1, 1)

local subtitle = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
subtitle:SetPoint("TOP", title, "BOTTOM", 0, -2)
subtitle:SetText("Made By Rist to Steal Your Gold")
subtitle:SetFont(subtitle:GetFont(), 11)
subtitle:SetTextColor(1, 0.85, 0.2, 1)

local progressBarBackground = CreateFrame("Frame", nil, frame, "BackdropTemplate")
progressBarBackground:SetSize(FRAME_WIDTH - 2*PADDING, 20)
progressBarBackground:SetPoint("TOP", frame, "TOP", 0, -58)
progressBarBackground:SetBackdrop({
    bgFile = "Interface\\Buttons\\WHITE8x8",
    edgeFile = ROUNDED_EDGE,
    tile = false, tileSize = 0, edgeSize = ROUNDED_EDGE_SIZE,
    insets = SUB_INSETS
})
progressBarBackground:SetBackdropColor(0.17,0.22,0.28,0.95)
progressBarBackground:Hide()

local progressBar = CreateFrame("StatusBar", nil, progressBarBackground, "BackdropTemplate")
progressBar:SetSize(FRAME_WIDTH - 2*PADDING - 6, 14)
progressBar:SetPoint("CENTER", progressBarBackground, "CENTER", 0, 0)
progressBar:SetStatusBarTexture("Interface\\TARGETINGFRAME\\UI-StatusBar")
progressBar.label = progressBar:CreateFontString(nil, "OVERLAY", "GameFontNormal")
progressBar.label:SetPoint("CENTER", progressBar, "CENTER", 0, 0)
progressBar.label:SetText("")

local tabNames = {"Game", "Stats", "Leaderboard"}
local tabs, frame_tabContents = {}, {}
local activeTab = 1
frame.tabContents = frame_tabContents

local hasShownWelcome = false
local lastResult = nil

local gameActive, signupActive, rollActive, gameEnded = false, false, false, false
local currentMax = 1000
local signedUpPlayers = {} -- [name] = {rolled = false, roll = nil}
local signupTimer, rollTimer = nil, nil
local signupTimeLeft, rollTimeLeft = 20, 60
local tiebreakActive = false
local tiebreakType = nil -- "winner" or "loser"
local tiebreakPlayers = {}
local tiebreakOriginalValue = nil
local tiebreakRolls = {}

if not MLBRollDB then MLBRollDB = {} end

-- Tab content frames
local gameContent = CreateFrame("Frame", nil, frame, "BackdropTemplate")
gameContent:SetSize(FRAME_WIDTH-2*PADDING, FRAME_HEIGHT-140)
gameContent:SetPoint("TOPLEFT", frame, "TOPLEFT", PADDING, -85)
frame.tabContents[1] = gameContent

local statsContent = CreateFrame("Frame", nil, frame, "BackdropTemplate")
statsContent:SetSize(FRAME_WIDTH-2*PADDING, FRAME_HEIGHT-140)
statsContent:SetPoint("TOPLEFT", frame, "TOPLEFT", PADDING, -85)
statsContent.text = statsContent:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
statsContent.text:SetPoint("TOPLEFT", statsContent, "TOPLEFT", 12, -8)
statsContent.text:SetJustifyH("LEFT")
statsContent.text:SetFont(statsContent.text:GetFont(), 14)
statsContent.text:SetWidth(statsContent:GetWidth()-24)
statsContent.text:SetHeight(statsContent:GetHeight()-24)
statsContent:Hide()
frame.tabContents[2] = statsContent

local lbContent = CreateFrame("Frame", nil, frame, "BackdropTemplate")
lbContent:SetSize(FRAME_WIDTH-2*PADDING, FRAME_HEIGHT-140)
lbContent:SetPoint("TOPLEFT", frame, "TOPLEFT", PADDING, -85)
lbContent.text = lbContent:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
lbContent.text:SetPoint("TOPLEFT", lbContent, "TOPLEFT", 12, -8)
lbContent.text:SetJustifyH("LEFT")
lbContent.text:SetFont(lbContent.text:GetFont(), 14)
lbContent.text:SetWidth(lbContent:GetWidth()-24)
lbContent.text:SetHeight(lbContent:GetHeight()-24)
lbContent:Hide()
frame.tabContents[3] = lbContent

-- Tab switching function (define FIRST so OnClick handlers work)
local function ShowTab(tab)
    activeTab = tab
    for i, t in ipairs(tabs) do
        if i == tab then
            t:SetBackdropColor(0.18, 0.34, 0.64, 1)
            t.button.label:SetTextColor(1,1,0.7)
        else
            t:SetBackdropColor(0.13, 0.20, 0.32, 0.92)
            t.button.label:SetTextColor(0.85,0.85,0.95,1)
        end
    end
    for i, content in ipairs(frame.tabContents) do
        if i == tab then content:Show() else content:Hide() end
    end
    -- Optionally, update tab content if needed
    if tab == 2 and statsContent.UpdateStatsTab then statsContent:UpdateStatsTab() end
    if tab == 3 and lbContent.UpdateLeaderboardTab then lbContent:UpdateLeaderboardTab() end
end

-- Tab setup (AFTER ShowTab is defined!)
for i, name in ipairs(tabNames) do
    local tabBg = CreateFrame("Frame", nil, frame, "BackdropTemplate")
    tabBg:SetSize(120, 28)
    tabBg:SetPoint("BOTTOMLEFT", frame, "BOTTOMLEFT", PADDING + (i-1)*128, PADDING-2)
    tabBg:SetBackdrop({
        bgFile = "Interface\\Buttons\\WHITE8x8",
        edgeFile = ROUNDED_EDGE,
        tile = false, tileSize = 0, edgeSize = ROUNDED_EDGE_SIZE,
        insets = SUB_INSETS
    })
    tabBg:SetBackdropColor(0.13, 0.20, 0.32, 0.92)
    tabBg:EnableMouse(true)
    tabBg:SetFrameLevel(frame:GetFrameLevel() + 1)

    local tabBtn = CreateFrame("Button", nil, tabBg)
    tabBtn:SetAllPoints(tabBg)
    tabBtn.label = tabBtn:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
    tabBtn.label:SetPoint("CENTER", tabBtn, "CENTER", 0, 1)
    tabBtn.label:SetText(name)
    tabBtn.label:SetTextColor(0.85,0.85,0.95,1)
    tabBtn:SetScript("OnClick", function() ShowTab(i) end)
    tabs[i] = tabBg
    tabs[i].button = tabBtn
end

-- Game tab controls
local controlBox = CreateFrame("Frame", nil, gameContent, "BackdropTemplate")
controlBox:SetSize(gameContent:GetWidth()-6, 46)
controlBox:SetPoint("TOPLEFT", gameContent, "TOPLEFT", 3, -3)
controlBox:SetBackdrop({
    bgFile = "Interface\\Buttons\\WHITE8x8",
    edgeFile = ROUNDED_EDGE,
    tile = false, tileSize = 0, edgeSize = ROUNDED_EDGE_SIZE,
    insets = SUB_INSETS
})
controlBox:SetBackdropColor(0.22, 0.24, 0.38, 0.98)

local editBoxLabel = controlBox:CreateFontString(nil, "OVERLAY", "GameFontNormal")
editBoxLabel:SetPoint("LEFT", controlBox, "LEFT", 16, 0)
editBoxLabel:SetText("Roll Max:")
editBoxLabel:SetTextColor(0.98, 0.95, 0.65, 1)

gameContent.editBox = CreateFrame("EditBox", nil, controlBox, "InputBoxTemplate")
gameContent.editBox:SetSize(92, 26)
gameContent.editBox:SetPoint("LEFT", editBoxLabel, "RIGHT", 10, 0)
gameContent.editBox:SetAutoFocus(false)
gameContent.editBox:SetText("1000")
gameContent.editBox:SetScript("OnEnterPressed", function(self)
    self:ClearFocus()
end)

gameContent.startBtn = CreateFrame("Button", nil, controlBox, "GameMenuButtonTemplate")
gameContent.startBtn:SetSize(90, 26)
gameContent.startBtn:SetPoint("LEFT", gameContent.editBox, "RIGHT", 12, 0)
gameContent.startBtn:SetText("Start Game")
gameContent.startBtn:SetNormalFontObject("GameFontHighlightLarge")
gameContent.startBtn:SetHighlightTexture("Interface\\Buttons\\UI-Button-Highlight")

gameContent.endBtn = CreateFrame("Button", nil, controlBox, "GameMenuButtonTemplate")
gameContent.endBtn:SetSize(90, 26)
gameContent.endBtn:SetPoint("LEFT", gameContent.startBtn, "RIGHT", 12, 0)
gameContent.endBtn:SetText("End Game")
gameContent.endBtn:SetNormalFontObject("GameFontNormalLarge")

local statusBox = CreateFrame("Frame", nil, gameContent, "BackdropTemplate")
statusBox:SetSize(gameContent:GetWidth()-6, gameContent:GetHeight()-60)
statusBox:SetPoint("TOPLEFT", gameContent, "TOPLEFT", 3, -55)
statusBox:SetBackdrop({
    bgFile = "Interface\\Buttons\\WHITE8x8",
    edgeFile = ROUNDED_EDGE,
    tile = false, tileSize = 0, edgeSize = ROUNDED_EDGE_SIZE,
    insets = SUB_INSETS
})
statusBox:SetBackdropColor(0.16, 0.17, 0.22, 0.93)

gameContent.text = statusBox:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
gameContent.text:SetPoint("TOPLEFT", statusBox, "TOPLEFT", 12, -18)
gameContent.text:SetJustifyH("LEFT")
gameContent.text:SetJustifyV("TOP")
gameContent.text:SetFont(gameContent.text:GetFont(), 11)
gameContent.text:SetWidth(statusBox:GetWidth()-24)

local closeBtn = CreateFrame("Button", nil, frame, "UIPanelCloseButton")
closeBtn:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -8, -8)

-- Default tab content
gameContent.text:SetText("No game result yet. Start a game to play MLB Roll!")

function statsContent:UpdateStatsTab()
    self.text:SetText("Stats will go here.\nAdd more logic for real stats!")
end
function lbContent:UpdateLeaderboardTab()
    self.text:SetText("Leaderboard will go here.\nAdd more logic for real leaderboard!")
end

-- Show the first tab by default
ShowTab(1)

--THIS IS THE DIVIDER FOR THE GAME BUILD
-- Optionally, add statsContent.UpdateStatsTab and lbContent.UpdateLeaderboardTab functions here
-- For demo purposes, you can add:
function statsContent:UpdateStatsTab()
    self.text:SetText("Stats will go here.\nAdd more logic for real stats!")
end
function lbContent:UpdateLeaderboardTab()
    self.text:SetText("Leaderboard will go here.\nAdd more logic for real leaderboard!")
end

-- You can test them by clicking tabs now!

local function UpdateProgressBar()
    if signupActive then
        progressBarBackground:Show()
        progressBar:SetMinMaxValues(0, 20)
        progressBar:SetValue(signupTimeLeft)
        progressBar:SetStatusBarColor(0.17, 0.77, 0.23, 0.85)
        progressBar.label:SetText("Signups: " .. signupTimeLeft .. "s left")
    elseif rollActive then
        progressBarBackground:Show()
        progressBar:SetMinMaxValues(0, 60)
        progressBar:SetValue(rollTimeLeft)
        progressBar:SetStatusBarTexture("Interface\\TARGETINGFRAME\\UI-StatusBar")
        progressBar:SetStatusBarColor(0.77, 0.47, 0.17, 0.85)
        progressBar.label:SetText("Rolling: " .. rollTimeLeft .. "s left")
    else
        progressBarBackground:Hide()
    end
end

local function ResetGame()
    gameActive, signupActive, rollActive, gameEnded = false, false, false, false
    signedUpPlayers = {}
    signupTimer, rollTimer = nil, nil
    signupTimeLeft, rollTimeLeft = 20, 60
    tiebreakActive = false
    tiebreakType = nil
    tiebreakPlayers = {}
    tiebreakOriginalValue = nil
    tiebreakRolls = {}
    progressBarBackground:Hide()
end

local function GetSortedSignups()
    local list = {}
    for name, info in pairs(signedUpPlayers) do
        table.insert(list, {name = name, rolled = info.rolled, roll = info.roll})
    end
    table.sort(list, function(a, b) return a.name < b.name end)
    return list
end

local function GetWinner()
    local maxRoll = nil
    local winners = {}
    for name, info in pairs(signedUpPlayers) do
        if info.roll then
            if not maxRoll or info.roll > maxRoll then
                maxRoll = info.roll
                winners = {name}
            elseif info.roll == maxRoll then
                table.insert(winners, name)
            end
        end
    end
    return winners, maxRoll
end

local function GetLoser()
    local minRoll = nil
    local losers = {}
    for name, info in pairs(signedUpPlayers) do
        if info.roll then
            if not minRoll or info.roll < minRoll then
                minRoll = info.roll
                losers = {name}
            elseif info.roll == minRoll then
                table.insert(losers, name)
            end
        end
    end
    return losers, minRoll
end

local function AllPlayersRolled()
    for _, info in pairs(signedUpPlayers) do
        if not info.rolled then return false end
    end
    return true
end

local function AnnounceAndTrackChickens()
    local chickens = {}
    for name, info in pairs(signedUpPlayers) do
        if not info.rolled then
            if not MLBRollDB[name] then
                MLBRollDB[name] = {wins=0, losses=0, goldReceived=0, goldGiven=0, chickens=0}
            end
            MLBRollDB[name].chickens = (MLBRollDB[name].chickens or 0) + 1
            table.insert(chickens, name)
        end
    end
    for _, name in ipairs(chickens) do
        SendChatMessage("MLB Roll: " .. name .. " chickened out!", "RAID")
    end
end

local function UpdateGameTab()
    UpdateProgressBar()
    local status = ""
    if not hasShownWelcome then
        hasShownWelcome = true
        status = "|cffffff00Welcome to MLB Roll!|r\n\nSet your roll max and click Start Game. Type \"1\" in raid chat to sign up."
    elseif lastResult then
        status = string.format("|cff00ff00Winner: %s (%d)|r\n|cffff3333Loser: %s (%d)|r\n|cffffff00Payout: %s owes %s %d gold|r",
            lastResult.winner, lastResult.winRoll, lastResult.loser, lastResult.loseRoll, lastResult.loser, lastResult.winner, lastResult.payout)
    elseif not gameActive then
        status = "No game result yet. Start a game to play MLB Roll!"
    else
        if signupActive then
            status = "Game Started!\nRoll range: |cffffff00" .. currentMax .. "|r\n"
            local signups = GetSortedSignups()
            if #signups == 0 then
                status = status .. "Waiting for players to sign up in raid chat with \"1\"..."
            else
                status = status .. "Signed-up players:\n"
                for _, info in ipairs(signups) do
                    status = status .. ("|cffffff00%s|r\n"):format(info.name)
                end
            end
        elseif rollActive then
            status = "Signups closed!\nRoll range: |cffffff00" .. currentMax .. "|r\n"
            local signups = GetSortedSignups()
            for _, info in ipairs(signups) do
                if info.rolled and info.roll then
                    status = status .. ("|cff00ff00%s|r rolled |cffffff00%d|r\n"):format(info.name, info.roll)
                else
                    status = status .. ("|cffffff00%s|r (waiting to roll)\n"):format(info.name)
                end
            end
        elseif tiebreakActive then
            if tiebreakType == "winner" then
                status = "Tiebreak for winner!\nTied high rollers (" .. tiebreakOriginalValue .. "):\n"
            elseif tiebreakType == "loser" then
                status = "Tiebreak for loser!\nTied low rollers (" .. tiebreakOriginalValue .. "):\n"
            end
            for _, name in ipairs(tiebreakPlayers) do
                status = status .. ("|cffffff00%s|r\n"):format(name)
            end
            status = status .. "\nOnly tied players should roll again."
        elseif gameEnded then
            status = "Game Ended!\nNo winner or loser detected."
        end
    end
    gameContent.text:SetText(status)
end

local function EndSignupPeriod()
    signupActive = false
    UpdateGameTab()
    local signups = GetSortedSignups()
    if #signups == 0 then
        gameActive = false
        SendChatMessage("MLB Roll: No Signups Received", "RAID")
        gameEnded = true
        UpdateGameTab()
        return
    end

    rollActive = true
    rollTimeLeft = 60
    UpdateGameTab()
    SendChatMessage("MLB Roll: Signups closed! You have 60 seconds to roll.", "RAID")
    UpdateProgressBar()
    rollTimer = C_Timer.NewTicker(1, function()
        rollTimeLeft = rollTimeLeft - 1
        UpdateProgressBar()
        if rollTimeLeft == 30 then
            local notRolled = {}
            for name, info in pairs(signedUpPlayers) do
                if not info.rolled then table.insert(notRolled, name) end
            end
            if #notRolled > 0 then
                SendChatMessage("MLB Roll: 30 seconds left to roll! Waiting on: " .. table.concat(notRolled, ", "), "RAID")
            end
        end
        UpdateGameTab()
        if AllPlayersRolled() or rollTimeLeft <= 0 then
            rollTimer:Cancel()
            rollActive = false
            local highTies, highRoll = GetWinner()
            local lowTies, lowRoll = GetLoser()
            local anyRolled = false
            for _, info in pairs(signedUpPlayers) do
                if info.rolled then
                    anyRolled = true
                    break
                end
            end
            if not anyRolled then
                gameActive = false
                gameEnded = true
                UpdateGameTab()
                SendChatMessage("MLB Roll: No one rolled!", "RAID")
                AnnounceAndTrackChickens()
                return
            end
            if #highTies > 1 then
                tiebreakActive = true
                tiebreakType = "winner"
                tiebreakPlayers = highTies
                tiebreakOriginalValue = highRoll
                tiebreakRolls = {}
                UpdateGameTab()
                SendChatMessage("MLB Roll: Tiebreak for WINNER! " .. table.concat(highTies, " and ") .. " tied with " .. highRoll .. ". Please /roll " .. currentMax .. " again!", "RAID")
            elseif #lowTies > 1 then
                tiebreakActive = true
                tiebreakType = "loser"
                tiebreakPlayers = lowTies
                tiebreakOriginalValue = lowRoll
                tiebreakRolls = {}
                UpdateGameTab()
                SendChatMessage("MLB Roll: Tiebreak for LOSER! " .. table.concat(lowTies, " and ") .. " tied with " .. lowRoll .. ". Please /roll " .. currentMax .. " again!", "RAID")
            else
                gameActive = false
                gameEnded = true
                lastResult = {
                    winner = highTies[1],
                    winRoll = highRoll,
                    loser = lowTies[1],
                    loseRoll = lowRoll,
                    payout = highRoll - lowRoll
                }
                UpdateGameTab()
                local winner = highTies[1]
                local loser = lowTies[1]
                SendChatMessage("MLB Roll: Winner is " .. winner .. " with " .. highRoll .. "! Loser is " .. loser .. " with " .. lowRoll .. ".", "RAID")
                local payout = highRoll - lowRoll
                if payout > 0 then
                    SendChatMessage("MLB Roll: " .. loser .. " owes " .. winner .. " " .. payout .. " gold.", "RAID")
                end
                if not MLBRollDB[winner] then MLBRollDB[winner] = {wins=0, losses=0, goldReceived=0, goldGiven=0, chickens=0} end
                MLBRollDB[winner].wins = MLBRollDB[winner].wins + 1
                MLBRollDB[winner].goldReceived = MLBRollDB[winner].goldReceived + payout
                if not MLBRollDB[loser] then MLBRollDB[loser] = {wins=0, losses=0, goldReceived=0, goldGiven=0, chickens=0} end
                MLBRollDB[loser].losses = MLBRollDB[loser].losses + 1
                MLBRollDB[loser].goldGiven = MLBRollDB[loser].goldGiven + payout
                AnnounceAndTrackChickens()
            end
        end
    end)
end

local function StartSignupPeriod()
    signupActive = true
    rollActive = false
    gameEnded = false
    signupTimeLeft = 20
    UpdateGameTab()
    UpdateProgressBar()
    signupTimer = C_Timer.NewTicker(1, function()
        signupTimeLeft = signupTimeLeft - 1
        UpdateProgressBar()
        if signupTimeLeft == 5 then
            SendChatMessage("MLB Roll: Signups close in 5 seconds!", "RAID")
        end
        if signupTimeLeft <= 0 then
            signupTimer:Cancel()
            EndSignupPeriod()
        end
    end)
end

gameContent.startBtn:SetScript("OnClick", function()
    local val = tonumber(gameContent.editBox:GetText())
    if not val or val < 2 or val > 1000000 then
        print("Enter a valid roll max (2-1000000)")
        return
    end
    currentMax = val
    ResetGame()
    gameActive = true
    UpdateGameTab()
    SendChatMessage("MLB Roll " .. currentMax .. " Game Started. Enter '1' to Join Game. Signups close in 20 seconds.", "RAID")
    StartSignupPeriod()
end)

gameContent.endBtn:SetScript("OnClick", function()
    if not gameActive and not signupActive and not rollActive and not tiebreakActive then return end
    if signupTimer then signupTimer:Cancel() end
    if rollTimer then rollTimer:Cancel() end
    gameActive = false
    signupActive = false
    rollActive = false
    tiebreakActive = false
    gameEnded = true
    UpdateGameTab()
    local highTies, highRoll = GetWinner()
    local lowTies, lowRoll = GetLoser()
    if #highTies > 1 then
        SendChatMessage("MLB Roll: Tiebreak for WINNER! " .. table.concat(highTies, " and ") .. " tied with " .. highRoll .. ".", "RAID")
    elseif #lowTies > 1 then
        SendChatMessage("MLB Roll: Tiebreak for LOSER! " .. table.concat(lowTies, " and ") .. " tied with " .. lowRoll .. ".", "RAID")
    else
        lastResult = {
            winner = highTies[1],
            winRoll = highRoll,
            loser = lowTies[1],
            loseRoll = lowRoll,
            payout = highRoll - lowRoll
        }
        UpdateGameTab()
        local winner = highTies[1]
        local loser = lowTies[1]
        SendChatMessage("MLB Roll: Winner is " .. winner .. " with " .. highRoll .. "! Loser is " .. loser .. " with " .. lowRoll .. ".", "RAID")
        local payout = highRoll - lowRoll
        if payout > 0 then
            SendChatMessage("MLB Roll: " .. loser .. " owes " .. winner .. " " .. payout .. " gold.", "RAID")
        end
        AnnounceAndTrackChickens()
    end
end)

frame:SetScript("OnHide", function()
    if gameContent.editBox then
        gameContent.editBox:ClearFocus()
    end
end)

local eventFrame = CreateFrame("Frame")
eventFrame:RegisterEvent("CHAT_MSG_RAID")
eventFrame:RegisterEvent("CHAT_MSG_RAID_LEADER")
eventFrame:RegisterEvent("CHAT_MSG_SYSTEM")
eventFrame:SetScript("OnEvent", function(self, event, msg, author)
    if not gameActive and not tiebreakActive then return end

    if signupActive and (event == "CHAT_MSG_RAID" or event == "CHAT_MSG_RAID_LEADER") and msg and msg:trim() == "1" then
        local name = author and author ~= "" and author:match("^[^-]+") or UnitName("player")
        if not signedUpPlayers[name] then
            signedUpPlayers[name] = {rolled = false, roll = nil}
            UpdateGameTab()
        end
        return
    end

    if rollActive and event == "CHAT_MSG_SYSTEM" then
        local player, roll, min, max = msg:match("(.+) rolls (%d+) %((%d+)%-(%d+)%)")
        if player then
            player = player:match("^[^-]+")
            if signedUpPlayers[player] then
                if tonumber(min) ~= 1 or tonumber(max) ~= currentMax then
                    SendChatMessage("Roll Rejected. Roll 1-" .. currentMax, "WHISPER", nil, player)
                    return
                end
                if not signedUpPlayers[player].rolled then
                    signedUpPlayers[player].rolled = true
                    signedUpPlayers[player].roll = tonumber(roll)
                    UpdateGameTab()
                    if AllPlayersRolled() and rollActive and rollTimer then
                        rollTimer:Cancel()
                        rollActive = false
                        local highTies, highRoll = GetWinner()
                        local lowTies, lowRoll = GetLoser()
                        local anyRolled = false
                        for _, info in pairs(signedUpPlayers) do
                            if info.rolled then
                                anyRolled = true
                                break
                            end
                        end
                        if not anyRolled then
                            gameActive = false
                            gameEnded = true
                            UpdateGameTab()
                            SendChatMessage("MLB Roll: No one rolled!", "RAID")
                            AnnounceAndTrackChickens()
                            return
                        end
                        if #highTies > 1 then
                            tiebreakActive = true
                            tiebreakType = "winner"
                            tiebreakPlayers = highTies
                            tiebreakOriginalValue = highRoll
                            tiebreakRolls = {}
                            UpdateGameTab()
                            SendChatMessage("MLB Roll: Tiebreak for WINNER! " .. table.concat(highTies, " and ") .. " tied with " .. highRoll .. ". Please /roll " .. currentMax .. " again!", "RAID")
                        elseif #lowTies > 1 then
                            tiebreakActive = true
                            tiebreakType = "loser"
                            tiebreakPlayers = lowTies
                            tiebreakOriginalValue = lowRoll
                            tiebreakRolls = {}
                            UpdateGameTab()
                            SendChatMessage("MLB Roll: Tiebreak for LOSER! " .. table.concat(lowTies, " and ") .. " tied with " .. lowRoll .. ". Please /roll " .. currentMax .. " again!", "RAID")
                        else
                            gameActive = false
                            gameEnded = true
                            lastResult = {
                                winner = highTies[1],
                                winRoll = highRoll,
                                loser = lowTies[1],
                                loseRoll = lowRoll,
                                payout = highRoll - lowRoll
                            }
                            UpdateGameTab()
                            local winner = highTies[1]
                            local loser = lowTies[1]
                            SendChatMessage("MLB Roll: Winner is " .. winner .. " with " .. highRoll .. "! Loser is " .. loser .. " with " .. lowRoll .. ".", "RAID")
                            local payout = highRoll - lowRoll
                            if payout > 0 then
                                SendChatMessage("MLB Roll: " .. loser .. " owes " .. winner .. " " .. payout .. " gold.", "RAID")
                            end
                            if not MLBRollDB[winner] then MLBRollDB[winner] = {wins=0, losses=0, goldReceived=0, goldGiven=0, chickens=0} end
                            MLBRollDB[winner].wins = MLBRollDB[winner].wins + 1
                            MLBRollDB[winner].goldReceived = MLBRollDB[winner].goldReceived + payout
                            if not MLBRollDB[loser] then MLBRollDB[loser] = {wins=0, losses=0, goldReceived=0, goldGiven=0, chickens=0} end
                            MLBRollDB[loser].losses = MLBRollDB[loser].losses + 1
                            MLBRollDB[loser].goldGiven = MLBRollDB[loser].goldGiven + payout
                            AnnounceAndTrackChickens()
                        end
                    end
                end
            end
        end
    end

    if tiebreakActive and event == "CHAT_MSG_SYSTEM" then
        local player, roll, min, max = msg:match("(.+) rolls (%d+) %((%d+)%-(%d+)%)")
        if player then
            player = player:match("^[^-]+")
            if tiebreakRolls[player] then return end
            for _, tieName in ipairs(tiebreakPlayers) do
                if player == tieName then
                    if tonumber(min) ~= 1 or tonumber(max) ~= currentMax then
                        SendChatMessage("Tiebreak Roll Rejected. Roll 1-" .. currentMax, "WHISPER", nil, player)
                        return
                    end
                    tiebreakRolls[player] = tonumber(roll)
                    local allRolled = true
                    for _, tieNameCheck in ipairs(tiebreakPlayers) do
                        if not tiebreakRolls[tieNameCheck] then allRolled = false break end
                    end
                    if allRolled then
                        local tbBest = nil
                        local tbNames = {}
                        for _, tieName in ipairs(tiebreakPlayers) do
                            local r = tiebreakRolls[tieName]
                            if tiebreakType == "winner" then
                                if not tbBest or r > tbBest then
                                    tbBest = r
                                    tbNames = {tieName}
                                elseif r == tbBest then
                                    table.insert(tbNames, tieName)
                                end
                            elseif tiebreakType == "loser" then
                                if not tbBest or r < tbBest then
                                    tbBest = r
                                    tbNames = {tieName}
                                elseif r == tbBest then
                                    table.insert(tbNames, tieName)
                                end
                            end
                        end

                        if #tbNames > 1 then
                            tiebreakPlayers = tbNames
                            tiebreakRolls = {}
                            UpdateGameTab()
                            if tiebreakType == "winner" then
                                SendChatMessage("MLB Roll: Tiebreak for WINNER! " .. table.concat(tbNames, " and ") .. " tied (" .. tbBest .. "). Please /roll " .. currentMax .. " again!", "RAID")
                            elseif tiebreakType == "loser" then
                                SendChatMessage("MLB Roll: Tiebreak for LOSER! " .. table.concat(tbNames, " and ") .. " tied (" .. tbBest .. "). Please /roll " .. currentMax .. " again!", "RAID")
                            end
                        else
                            local winner, loser, winRoll, loseRoll
                            if tiebreakType == "winner" then
                                winner = tbNames[1]
                                winRoll = tiebreakOriginalValue
                                local lowTies, lowRoll = GetLoser()
                                loser = lowTies[1]
                                loseRoll = lowRoll
                            else
                                loser = tbNames[1]
                                loseRoll = tiebreakOriginalValue
                                local highTies, highRoll = GetWinner()
                                winner = highTies[1]
                                winRoll = highRoll
                            end
                            tiebreakActive = false
                            gameActive = false
                            gameEnded = true
                            lastResult = {
                                winner = winner,
                                winRoll = winRoll,
                                loser = loser,
                                loseRoll = loseRoll,
                                payout = winRoll - loseRoll
                            }
                            UpdateGameTab()
                            SendChatMessage("MLB Roll: Winner is " .. winner .. " with " .. winRoll .. "! Loser is " .. loser .. " with " .. loseRoll .. ".", "RAID")
                            local payout = winRoll - loseRoll
                            if payout > 0 then
                                SendChatMessage("MLB Roll: " .. loser .. " owes " .. winner .. " " .. payout .. " gold.", "RAID")
                            end
                            if not MLBRollDB[winner] then MLBRollDB[winner] = {wins=0, losses=0, goldReceived=0, goldGiven=0, chickens=0} end
                            MLBRollDB[winner].wins = MLBRollDB[winner].wins + 1
                            MLBRollDB[winner].goldReceived = MLBRollDB[winner].goldReceived + payout
                            if not MLBRollDB[loser] then MLBRollDB[loser] = {wins=0, losses=0, goldReceived=0, goldGiven=0, chickens=0} end
                            MLBRollDB[loser].losses = MLBRollDB[loser].losses + 1
                            MLBRollDB[loser].goldGiven = MLBRollDB[loser].goldGiven + payout
                            AnnounceAndTrackChickens()
                        end
                    end
                end
            end
        end
    end
end)

local function ShowTab(tab)
    activeTab = tab
    for i, t in ipairs(tabs) do
        if i == tab then
            t:SetBackdropColor(0.18, 0.34, 0.64, 1)
            t.button.label:SetTextColor(1,1,0.7)
        else
            t:SetBackdropColor(0.13, 0.20, 0.32, 0.92)
            t.button.label:SetTextColor(0.85,0.85,0.95,1)
        end
    end
    for i, content in ipairs(frame.tabContents) do
        if i == tab then content:Show() else content:Hide() end
    end
    if gameContent.editBox then
        gameContent.editBox:ClearFocus()
    end
end

frame:SetScript("OnHide", function()
    if gameContent.editBox then
        gameContent.editBox:ClearFocus()
    end
end)

local function UpdateStatsTab()
    local player = UnitName("player")
    local stats = MLBRollDB[player]
    if not stats then
        statsContent.text:SetText("This is the Stats tab.\n\nNo stats recorded for you yet.")
        return
    end
    local txt = "Your MLB Roll Stats:\n\n"
    txt = txt .. ("Wins: %d\nLosses: %d\nGold Given: %d\nGold Received: %d\nChickens: %d\n"):format(stats.wins or 0, stats.losses or 0, stats.goldGiven or 0, stats.goldReceived or 0, stats.chickens or 0)
    statsContent.text:SetText(txt)
end

statsContent:SetScript("OnShow", UpdateStatsTab)

local function GetSortedLeaderboard()
    local sorted_winners = {}
    local sorted_losers = {}
    local sorted_chickens = {}
    for name, stats in pairs(MLBRollDB) do
        table.insert(sorted_winners, {name=name, gold=stats.goldReceived or 0})
        table.insert(sorted_losers, {name=name, gold=stats.goldGiven or 0})
        table.insert(sorted_chickens, {name=name, chickens=stats.chickens or 0})
    end
    table.sort(sorted_winners, function(a,b) return a.gold > b.gold end)
    table.sort(sorted_losers, function(a,b) return a.gold > b.gold end)
    table.sort(sorted_chickens, function(a,b) return a.chickens > b.chickens end)
    return sorted_winners, sorted_losers, sorted_chickens
end

local function AnnounceTop5WinnersAndLosers()
    local sorted_winners, sorted_losers = GetSortedLeaderboard()
    SendChatMessage("MLB Roll Leaderboard - Top 5 Winners (Gold Won):", "RAID")
    for i,v in ipairs(sorted_winners) do
        if i > 5 then break end
        SendChatMessage(("%d. %s - %d gold"):format(i, v.name, v.gold), "RAID")
    end
    SendChatMessage("MLB Roll Leaderboard - Top 5 Losers (Gold Lost):", "RAID")
    for i,v in ipairs(sorted_losers) do
        if i > 5 then break end
        SendChatMessage(("%d. %s - %d gold"):format(i, v.name, v.gold), "RAID")
    end
end

local function AnnounceTop5Chickens()
    local _, _, sorted_chickens = GetSortedLeaderboard()
    SendChatMessage("MLB Roll Leaderboard - Top 5 Chickens:", "RAID")
    for i,v in ipairs(sorted_chickens) do
        if i > 5 then break end
        SendChatMessage(("%d. %s - %d chickens"):format(i, v.name, v.chickens), "RAID")
    end
end

local function AnnounceTop30Losers()
    local _, sorted_losers = GetSortedLeaderboard()
    SendChatMessage("MLB Roll Leaderboard - Top 30 Losers (Gold Lost):", "RAID")
    for i,v in ipairs(sorted_losers) do
        if i > 30 then break end
        SendChatMessage(("%d. %s - %d gold"):format(i, v.name, v.gold), "RAID")
    end
end

local function CreateAnnounceButton(parent, x, y, label, tooltip, onClick)
    local btn = CreateFrame("Button", nil, parent, "GameMenuButtonTemplate")
    btn:SetSize(32, 22)
    btn:SetPoint("TOPLEFT", parent, "TOPLEFT", x, y)
    btn:SetText(label)
    btn:SetScript("OnClick", onClick)
    btn:SetScript("OnEnter", function(self)
        GameTooltip:SetOwner(self, "ANCHOR_BOTTOMRIGHT")
        GameTooltip:SetText(tooltip)
        GameTooltip:Show()
    end)
    btn:SetScript("OnLeave", function(self) GameTooltip:Hide() end)
    return btn
end

local function UpdateLeaderboardTab()
    local sorted_winners, sorted_losers, sorted_chickens = GetSortedLeaderboard()
    local txt = ""
    txt = txt .. "Top 5 Winners (Gold Won):\n"
    for i=1, math.min(5, #sorted_winners) do
        local v = sorted_winners[i]
        txt = txt .. ("%d. %s - %d gold\n"):format(i, v.name, v.gold)
    end
    txt = txt .. "\nTop 5 Losers (Gold Lost):\n"
    for i=1, math.min(5, #sorted_losers) do
        local v = sorted_losers[i]
        txt = txt .. ("%d. %s - %d gold\n"):format(i, v.name, v.gold)
    end
    txt = txt .. "\nTop 5 Chickens:\n"
    for i=1, math.min(5, #sorted_chickens) do
        local v = sorted_chickens[i]
        txt = txt .. ("%d. %s - %d chickens\n"):format(i, v.name, v.chickens)
    end
    txt = txt .. "\nTop 30 Losers (Gold Lost):\n"
    for i=1, math.min(30, #sorted_losers) do
        local v = sorted_losers[i]
        txt = txt .. ("%d. %s - %d gold\n"):format(i, v.name, v.gold)
    end
    lbContent.text:SetText(txt)

    if not lbContent.announceBtn1 then
        lbContent.announceBtn1 = CreateAnnounceButton(lbContent, 0, 0, "🥇🥈", "Announce Top5 Winners & Losers", AnnounceTop5WinnersAndLosers)
        lbContent.announceBtn2 = CreateAnnounceButton(lbContent, 40, 0, "🐔", "Announce Top5 Chickens", AnnounceTop5Chickens)
        lbContent.announceBtn3 = CreateAnnounceButton(lbContent, 80, 0, "💸", "Announce Top30 Losers", AnnounceTop30Losers)
    end
end

lbContent:SetScript("OnShow", UpdateLeaderboardTab)

ShowTab(1)
UpdateGameTab()

frame:Hide()

SLASH_MLB1 = "/mlb"
SlashCmdList["MLB"] = function()
    if frame:IsShown() then
        frame:Hide()
    else
        frame:Show()
        if gameContent.editBox then
            gameContent.editBox:ClearFocus()
        end
        UpdateGameTab()
    end
end

SLASH_MLBROLL1 = "/mlbroll"
SlashCmdList["MLBROLL"] = function()
    if frame:IsShown() then
        frame:Hide()
    else
        frame:Show()
        if gameContent.editBox then
            gameContent.editBox:ClearFocus()
        end
        UpdateGameTab()
    end
end
